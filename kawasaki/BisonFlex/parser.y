
/*
 * NOTE: Bison version 3.0 or higher recommended.
 * https://www.gnu.org/software/bison/manual/html_node/index.html
 */

/* +-------------------------------------------------+ *
 * | Bison configuration parameters:                 | *
 * +-------------------------------------------------+ */

%skeleton "lalr1.cc"
%defines

%define parse.assert true
%define parse.error  verbose

%define api.namespace     {moon}
%define parser_class_name {Parser}

%parse-param {ParseContext & ctx}
%lex-param   {ParseContext & ctx}

%{
/*
 * Nothing to be added in the prologue section at the moment.
 * Left it here because Vim's syntax highlighting gets messed
 * up if this section is missing.
 *
 * Most of the stuff depends on the header file, so they
 * must be placed inside the %code { } section below.
 */
%}

/* +-------------------------------------------------+ *
 * | Additional verbatin code sections:              | *
 * +-------------------------------------------------+ */

/*
 * 'Requires' section is added to generated parser header file.
 * Good place for forward declaration and types used in the yylval union.
 */
%code requires
{

#define INC_PARSER 1
#include "common.hpp"
#undef  INC_PARSER

} /* %code requires */

/*
 * The unqualified code section is added to the implementation file, after
 * the parser header is included, which is the right place for these.
 */
%code
{

#include "semantic_check.hpp"
#include "vm.hpp"

namespace moon
{

// Slightly shorter names for local usage:
using STNode = SyntaxTreeNode::Type;
using STEval = SyntaxTreeNode::Eval;

int yylex(SemanticVal * yylval, ParseContext & ctx)
{
    ctx.yylval = yylval;
    return ctx.lexer->yylex();
}

void Parser::error(const std::string & message)
{
    parserError(ctx, message);
}

} /* namespace moon */
} /* %code */

/* +-------------------------------------------------+ *
 * | Tokens read by the Lexer (terminal symbols):    | *
 * +-------------------------------------------------+ */

/*
 * In the rules below, we can either use the token id
 * (e.g. OP_ASSIGN) or its string alias (e.g. "=").
 * The string alias is also used to print the token
 * on error messages generated by Bison.
 */

/* Operators: arithmetical/assigment/unary */
%token OP_ASSIGN                  "="
%token OP_PLUS                    "+"
%token OP_MINUS                   "-"
%token OP_MULTIPLY                "*"
%token OP_DIVIDE                  "/"
%token OP_MODULO                  "%"    /////del
%token OP_PLUS_ASSIGN             "+="
%token OP_MINUS_ASSIGN            "-="
%token OP_MULTIPLY_ASSIGN         "*="
%token OP_DIVIDE_ASSIGN           "/="
%token OP_MODULO_ASSIGN           "%="  /////del

/* Operators: comparisson */
%token OP_CMP_GREATER_THAN        ">"
%token OP_CMP_LESS_THAN           "<"
%token OP_CMP_GREATER_EQUAL       ">="
%token OP_CMP_LESS_EQUAL          "<="
%token OP_CMP_EQUAL               "=="
%token OP_CMP_NOT_EQUAL           "!="

/* Operators: logical/boolean */
%token OP_LOGIC_AND               "and"
%token OP_LOGIC_OR                "or"
%token OP_LOGIC_NOT               "not"

/* Built-in type ids: */
%token TID_INT                    "int"    /////del
%token TID_LONG                   "long"   /////del
%token TID_FLT                    "float"  /////del 
%token TID_DBL                    "double"  /////del
%token TID_BOOL                   "bool"    /////del
%token TID_STR                    "str"     
%token TID_ARRAY                  "array"   
%token TID_RANGE                  "range"   /////del
%token TID_ANY                    "any"     /////del
%token TID_TYPEID                 "tid"     
%token TID_FUNC                   "function"

/* Language keywords: */
%token KW_IMPORT                  "import"   /////del
%token KW_IF                      "if"
%token KW_THEN                    "then"
%token KW_ELSE                    "else"
%token KW_ELSEIF                  "elseif"
%token KW_END                     "end"
%token KW_RETURN                  "return"
%token KW_LET                     "let"      /////del
%token KW_FUNC                    "func"     /////del
%token KW_MATCH                   "match"    /////del
%token KW_WITH                    "with"     /////del
%token KW_CASE                    "case"
%token KW_DEFAULT                 "default"   /////any
%token KW_IN                      "in"        /////del
%token KW_DO                      "do"         /////del
%token KW_FOR                     "for"    
%token KW_WHILE                   "while"
%token KW_LOOP                    "loop"
%token KW_BREAK                   "break"
%token KW_CONTINUE                "continue"
%token KW_TYPE                    "type"
%token KW_ENUM                    "enum"
%token KW_STRUCT                  "struct"
%token KW_TYPEOF                  "type_of"
%token KW_AS                      "as"
%token KW_NULL                    "null"

/* Literal constants: */
%token <asSymbol> INT_LITERAL     "literal integer constant"
%token <asSymbol> FLT_LITERAL     "literal floating-point constant"
%token <asSymbol> BOOL_LITERAL    "literal boolean constant"
%token <asSymbol> STR_LITERAL     "literal string constant"

/* Miscellaneous: */
%token            MEMBER_REF      "."
%token            OPEN_PAR        "("
%token            CLOSE_PAR       ")"
%token            OPEN_CBRAC      "{"
%token            CLOSE_CBRAC     "}"
%token            OPEN_BRAC       "["
%token            CLOSE_BRAC      "]"
%token            COMMA           ","
%token            SEMICOLON       ";"
%token            COLON           ":"
%token            RANGE           ".."
%token            VARARGS         "..."
%token            ARROW           "->"
%token <asSymbol> IDENTIFIER      "identifier"
%token            END_OF_FILE  0  "end of file"

/* +-------------------------------------------------+ *
 * | Operator associativity & rule semantic types:   | *
 * +-------------------------------------------------+ */

/*
 * Operator associativity: LEFT or RIGHT and precedences.
 * NOTES:
 * - Using associativity equivalent to the C language.
 * - Order of this list matters! Lower on page, higher precedence.
 * - These should match the order in the 'expression' rule below.
 */
%right OP_MODULO_ASSIGN
%right OP_DIVIDE_ASSIGN
%right OP_MULTIPLY_ASSIGN
%right OP_MINUS_ASSIGN
%right OP_PLUS_ASSIGN
%right OP_ASSIGN
%left  OP_LOGIC_OR
%left  OP_LOGIC_AND
%left  OP_CMP_NOT_EQUAL
%left  OP_CMP_EQUAL
%left  OP_CMP_GREATER_EQUAL
%left  OP_CMP_GREATER_THAN
%left  OP_CMP_LESS_EQUAL
%left  OP_CMP_LESS_THAN
%left  OP_MINUS
%left  OP_PLUS
%left  OP_MODULO
%left  OP_DIVIDE
%left  OP_MULTIPLY
%right OP_LOGIC_NOT
%right UNARY_MINUS /* Context depended fix for unary +,- */
%right UNARY_PLUS  /* See: https://www.gnu.org/software/bison/manual/html_node/Contextual-Precedence.html */
%left  KW_AS       /* Typecast operator (foo as bar) */
%left  OPEN_BRAC   /* Precedence added for the array subscript expression (foo[N]) */
%left  CLOSE_BRAC  /* Array subscript/access precedence */
%left  MEMBER_REF  /* Member access with the dot operator (foo.bar) */

/*
 * Types referenced inside the rules by the '$' signs.
 * E.g.: if you reference a '$' in rule 'type_identifier'
 * it will be a variable of type 'SyntaxTreeNode', as defined
 * in the SemanticVal/YYSTYPE union by the 'asSTNode' field.
 */
%type <asSTNode> type_identifier builtin_type optional_return_type import_statement
%type <asSTNode> literal_const_expression identifier_expression
%type <asSTNode> expression array_expression array_subscript_expression object_constructor_expression
%type <asSTNode> translation_unit statement optional_statement_list
%type <asSTNode> for_statement while_statement loop_statement break_statement continue_statement
%type <asSTNode> if_statement elseif_statement else_statement elseif_or_else_or_end
%type <asSTNode> enum_declaration enum_constant enum_constant_list
%type <asSTNode> struct_declaration struct_member_list
%type <asSTNode> func_call_expression func_declaration func_parameter_list_declaration parameter_list return_statement
%type <asSTNode> match_statement match_case match_default match_case_list match_param match_case_param
%type <asSTNode> range_expression range_param range_or_array_or_ident_or_call
%type <asSTNode> let_var_declaration typed_var_declaration
%type <asSTNode> type_alias_declaration expression_or_type_identifier
%type <asSTNode> typeof_expression typecast_expression member_ref_expression

/*
 * Rule the parser starts from. If not explicitly stated,
 * it uses the first nonterminal rule in the below grammar.
 */
%start translation_unit

/* +-------------------------------------------------+ *
 * | Yacc/Bison grammar rules:                       | *
 * +-------------------------------------------------+ */

/* ---- A couple definitions: ----

 * From the Bison manual:
   Each kind of syntactic unit or grouping is named by a 'symbol'. Those which are built by grouping
   smaller constructs according to grammatical rules are called nonterminal symbols; those which can't
   be subdivided are called terminal symbols or token types. We call a piece of input corresponding to
   a single terminal symbol a token, and a piece corresponding to a single nonterminal symbol a grouping.
   We can use the C language as an example of what symbols, terminal and nonterminal, mean.
   The tokens of C are identifiers, constants (numeric and string), and the various keywords,
   arithmetic operators and punctuation marks. So the terminal symbols of a grammar for C include
   `identifier`, `number`, `string`, plus one symbol for each keyword, operator or punctuation mark:
   `if`, `return`, `const`, `static`, `int`, `char`, `plus-sign`, `open-brace`, `close-brace`, etc...

 * A 'Shift' step advances in the input stream by one symbol.
   That shifted symbol becomes a new single-node parse tree.

 * A 'Reduce' step applies a completed grammar rule to some of the recent parse trees,
   joining them together as one tree with a new root symbol.

 * Statements:
   Statements do Something and are often composed of expressions (or other statements).
   Statements are everything that can make up a line. E.g.: if/while, return, function declaration, ...

 * Expressions:
   Expressions produce at least one value. Expressions only contain identifiers,
   literals and operators, where operators include arithmetic and boolean operators,
   the function call operator () the subscription operator [] and similar, and can
   be reduced to some kind of "value" or terminal symbol.

--------------------------------- */

%%

/*
 * NOTE: Rules that don't explicitly set $$ are
 * just returning the value of the first element.
 * i.e., it is the same as $$ = $1;
 */

/*---------------------------------------------------.
| Miscellaneous statements, literals, built-in types |
`---------------------------------------------------*/

/* Starting rule */
translation_unit
    : optional_statement_list { beginTranslationUnit(ctx, $1); }
    ;

/* Zero or more statements allowed */
optional_statement_list
    : optional_statement_list statement { $$ = newStatementNode(ctx, $1, $2); }
    | %empty { $$ = nullptr; }
    ;

statement
    : import_statement
    | struct_declaration
    | enum_declaration
    | type_alias_declaration
    | func_declaration
    | let_var_declaration
    | if_statement
    | loop_statement
    | while_statement
    | for_statement
    | match_statement
    | return_statement
    | break_statement
    | continue_statement
    | expression ";"
    ;

optional_semicolon
    : ";"
    | %empty
    ;

end_statement
    : "end" optional_semicolon
    ;

literal_const_expression
    : INT_LITERAL  { $$ = newLiteralNode(ctx, STEval::Long,   $1); }
    | FLT_LITERAL  { $$ = newLiteralNode(ctx, STEval::Double, $1); }
    | BOOL_LITERAL { $$ = newLiteralNode(ctx, STEval::Bool,   $1); }
    | STR_LITERAL  { $$ = newLiteralNode(ctx, STEval::Str,    $1); }
    | KW_NULL      { $$ = newLiteralNode(ctx, STEval::Null, ctx.symTable->findSymbol("null")); }
    ;

builtin_type
    : TID_INT    { $$ = newTypeIdNode(ctx, STEval::Int);    }
    | TID_LONG   { $$ = newTypeIdNode(ctx, STEval::Long);   }
    | TID_FLT    { $$ = newTypeIdNode(ctx, STEval::Float);  }
    | TID_DBL    { $$ = newTypeIdNode(ctx, STEval::Double); }
    | TID_BOOL   { $$ = newTypeIdNode(ctx, STEval::Bool);   }
    | TID_STR    { $$ = newTypeIdNode(ctx, STEval::Str);    }
    | TID_ARRAY  { $$ = newTypeIdNode(ctx, STEval::Array);  }
    | TID_RANGE  { $$ = newTypeIdNode(ctx, STEval::Range);  }
    | TID_ANY    { $$ = newTypeIdNode(ctx, STEval::Any);    }
    | TID_TYPEID { $$ = newTypeIdNode(ctx, STEval::Tid);    }
    | TID_FUNC   { $$ = newTypeIdNode(ctx, STEval::Func);   }
    ;

type_identifier
    : builtin_type
    | IDENTIFIER { $$ = newUDTNode(ctx, $1); }
    ;

identifier_expression
    : IDENTIFIER { $$ = newIdentNode(ctx, $1); }
    ;

import_statement
    : "import" STR_LITERAL ";" { $$ = handleImportDirective(ctx, $2); }
    ;

/*------------------------.
| First-class expressions |
`------------------------*/

/*
 * Notes on the 'expression' rule:
 * Operator precedence is determined by the line ordering of the following declarations;
 * the higher the line number of the declaration (lower on the page), higher the precedence.
 *
 * Operator precedence for Moon Lang follows the same precedences of C.
 * https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence
 */
expression
    : identifier_expression
    | literal_const_expression
    | array_expression
    | range_expression
    | object_constructor_expression
    | expression[L] "%="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprModAssign,       $L, $R); }
    | expression[L] "/="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprDivAssign,       $L, $R); }
    | expression[L] "*="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprMulAssign,       $L, $R); }
    | expression[L] "-="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprSubAssign,       $L, $R); }
    | expression[L] "+="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprAddAssign,       $L, $R); }
    | expression[L] "="   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprAssign,          $L, $R); }
    | expression[L] "or"  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprLogicOr,         $L, $R); }
    | expression[L] "and" expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprLogicAnd,        $L, $R); }
    | expression[L] "!="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprCmpNotEqual,     $L, $R); }
    | expression[L] "=="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprCmpEqual,        $L, $R); }
    | expression[L] ">="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprCmpGreaterEqual, $L, $R); }
    | expression[L] ">"   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprCmpGreaterThan,  $L, $R); }
    | expression[L] "<="  expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprCmpLessEqual,    $L, $R); }
    | expression[L] "<"   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprCmpLessThan,     $L, $R); }
    | expression[L] "-"   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprSubtract,        $L, $R); }
    | expression[L] "+"   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprAdd,             $L, $R); }
    | expression[L] "%"   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprModulo,          $L, $R); }
    | expression[L] "/"   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprDivide,          $L, $R); }
    | expression[L] "*"   expression[R] { $$ = newBinaryOpNode(ctx, STNode::ExprMultiply,        $L, $R); }
    | "not" expression[R]                   { $$ = newUnaryOpNode(ctx, STNode::ExprLogicNot,   OpCode::LogicNot, $R); }
    | "-"   expression[R] %prec UNARY_MINUS { $$ = newUnaryOpNode(ctx, STNode::ExprUnaryMinus, OpCode::Negate,   $R); }
    | "+"   expression[R] %prec UNARY_PLUS  { $$ = newUnaryOpNode(ctx, STNode::ExprUnaryPlus,  OpCode::Plus,     $R); }
    | typecast_expression
    | typeof_expression
    | array_subscript_expression
    | func_call_expression
    | member_ref_expression
    | "(" expression ")"
        {
            // Wrapping an expr in ( ) gives it the highest precedence.
            // So just reapply the rule with the new precedence.
            $$ = $2;
        }
    ;

expression_or_type_identifier
    : expression   /* expression already incorporates identifier_expression */
    | builtin_type /* so all we need to add are the built-in types */
    ;

typeof_expression
    : KW_TYPEOF "(" expression_or_type_identifier ")"
        {
            $$ = newTypeofNode(ctx, $3);
        }
    ;

typecast_expression
    : expression[L] "as" type_identifier[R]
        {
            $$ = newTypecastNode(ctx, $L, $R);
        }
    ;

member_ref_expression
    : expression[L] "." expression[R]
        {
            $$ = newBinaryOpNode(ctx, STNode::ExprMemberRef, $L, $R);
        }
    ;

/*------------------------------.
| Parameter lists and functions |
`------------------------------*/

/* Shared by constructors, function calls and array literals */
parameter_list
    : expression
    | expression "," parameter_list
        {
            $$ = $1;
            $$->setChild(0, $3);
        }
    | %empty
        {
            $$ = nullptr;
        }
    ;

func_parameter_list_declaration
    : typed_var_declaration
    | typed_var_declaration "," func_parameter_list_declaration
        {
            $$ = $1;
            $$->setChild(0, $3);
        }
    | IDENTIFIER "..."
        {
            $$ = newVarArgsNode(ctx, $1);
        }
    | %empty
        {
            $$ = nullptr;
        }
    ;

func_call_expression
    : IDENTIFIER "(" parameter_list ")"
        {
            $$ = newFunctionCallNode(ctx, $1, $3);
        }
    ;

func_declaration
    : "func" IDENTIFIER { ctx.varInfo->beginFunc(ctx, $2); } "(" func_parameter_list_declaration ")" optional_return_type
    { registerNewFunction(ctx, $2, $5, $7); } optional_statement_list end_statement
        {
            $$ = newFunctionDeclNode(ctx, $2, $5, $7, $9);
            ctx.varInfo->endFunc(ctx);
        }
    ;

/* A function declaration can either have an explicit return type or implicit void return */
optional_return_type
    : "->" type_identifier
        {
            $$ = $2;
        }
    | %empty
        {
            $$ = newTypeIdNode(ctx, STEval::Void);
        }
    ;

/*-----------------------------------.
| Array literals and array subscript |
`-----------------------------------*/

array_expression
    : "[" parameter_list "]"
        {
            $$ = newArrayLiteralNode(ctx, $2);
        }
    ;

array_subscript_expression
    : expression "[" expression "]"
        {
            $$ = newArraySubscriptNode(ctx, $1, $3);
        }
    ;

/*------------------------.
| Object constructor call |
`------------------------*/

object_constructor_expression
    : type_identifier "{" parameter_list "}"
        {
            $$ = newObjConstructorCallNode(ctx, $1, $3);
        }
    ;

/*-----------------.
| Var declarations |
`-----------------*/

/* The type node will always be the second child (child[1]), if present */
typed_var_declaration
    : IDENTIFIER ":" type_identifier
        {
            $$ = newVarDeclNode(ctx, $1, nullptr, $3, $3->evalType);
        }
    ;

/* The type node will always be the second child (child[1]), if present */
let_var_declaration
    : "let" IDENTIFIER ":" type_identifier "=" expression ";"
        {
            $$ = newVarDeclNode(ctx, $2, $6, $4, $4->evalType);
        }
    | "let" IDENTIFIER ":" type_identifier ";"
        {
            $$ = newVarDeclNode(ctx, $2, nullptr, $4, $4->evalType);
        }
    | "let" IDENTIFIER "=" expression ";"
        {
            $$ = newVarDeclNode(ctx, $2, $4, nullptr, $4->evalType);
        }
    ;

/*----------------------------.
| If, else, elseif statements |
`----------------------------*/

if_statement
    : "if" expression "then" optional_statement_list end_statement
        {
            $$ = newCompareNode(ctx, STNode::IfThenStatement, $2, $4, nullptr);
        }
    | "if" expression "then" optional_statement_list else_statement
        {
            $$ = newCompareNode(ctx, STNode::IfThenElseStatement, $2, $4, $5);
        }
    | "if" expression "then" optional_statement_list elseif_statement
        {
            $$ = newCompareNode(ctx, STNode::IfThenElseIfStatement, $2, $4, $5);
        }
    ;

elseif_statement
    : "elseif" expression "then" optional_statement_list elseif_or_else_or_end
        {
            $$ = newCompareNode(ctx, STNode::IfThenElseIfStatement, $2, $4, $5);
        }
    ;

else_statement
    : "else" optional_statement_list end_statement { $$ = $2; }
    ;

elseif_or_else_or_end
    : elseif_statement
    | else_statement
    | end_statement { $$ = nullptr; }
    ;

/*--------------------------.
| Loops and jump statements |
`--------------------------*/

return_statement
    : "return" ";"            { $$ = newReturnNode(ctx, nullptr); }
    | "return" expression ";" { $$ = newReturnNode(ctx, $2); }
    ;

break_statement
    : "break" ";" { $$ = newLoopJumpNode(ctx, STNode::BreakStatement); }
    ;

continue_statement
    : "continue" ";" { $$ = newLoopJumpNode(ctx, STNode::ContinueStatement); }
    ;

loop_statement
    : "loop" { ctx.varInfo->insideLoopStmt = true; } optional_statement_list end_statement
        {
            $$ = newLoopNode(ctx, STNode::LoopStatement, nullptr, $3);
            ctx.varInfo->insideLoopStmt = false;
        }
    ;

while_statement
    : "while" expression "do" { ctx.varInfo->insideLoopStmt = true; } optional_statement_list end_statement
        {
            $$ = newLoopNode(ctx, STNode::WhileStatement, $2, $5);
            ctx.varInfo->insideLoopStmt = false;
        }
    ;

for_statement
    : "for" IDENTIFIER "in" range_or_array_or_ident_or_call "do"
    { ctx.varInfo->beginForLoop(ctx, $2, $4); } optional_statement_list end_statement
        {
            $$ = newLoopNode(ctx, STNode::ForStatement, $4, $7);
            ctx.varInfo->endForLoop(ctx);
        }
    ;

/*-----------------------.
| Match switch statement |
`-----------------------*/

/* Things allowed on a 'match X with' statement: */
match_param
    : literal_const_expression
    | identifier_expression
    | array_subscript_expression
    | func_call_expression
    ;

/* Things that can appear as the argument of a 'case' statement: */
match_case_param
    : literal_const_expression
    | range_or_array_or_ident_or_call
    ;

match_statement
    : "match" match_param "with" match_case_list end_statement
        {
            $$ = ctx.syntTree->newNode(STNode::MatchStatement, $2, $4, nullptr, $2->evalType);
        }
    ;

match_default
    : "default" "->" optional_statement_list end_statement
        {
            $$ = ctx.syntTree->newNode(STNode::MatchDefaultStatement, nullptr, $3, nullptr, STEval::Void);
        }
    ;

match_case
    : "case" match_case_param "->" optional_statement_list end_statement
        {
            $$ = ctx.syntTree->newNode(STNode::MatchCaseStatement, $2, $4, nullptr, $2->evalType);
        }
    ;

match_case_list
    : match_case match_case_list
        {
            $$ = $1;
            $$->setChild(2, $2);
        }
    | match_default
    | %empty
        {
            $$ = nullptr;
        }
    ;

/*------------------.
| Range expressions |
`------------------*/

range_or_array_or_ident_or_call
    : range_expression
    | array_expression
    | array_subscript_expression
    | func_call_expression
    | identifier_expression
    ;

range_expression
    : range_param ".." range_param
        {
            // First child reserved for parameter_list chains
            $$ = ctx.syntTree->newNode(STNode::ExprRange, nullptr, $1, $3, STEval::Range);
        }
    ;

/*
 * Possible elements for a range parameter:
 * variables/identifiers:         x .. y
 * function return val:           0 .. len()
 * integer literals:              0 .. 10
 * strings (OK for single char):  "a" .. "z"
 */
range_param
    : func_call_expression
    | identifier_expression
    | INT_LITERAL { $$ = newRangeParamNode(ctx, $1); }
    | STR_LITERAL { $$ = newRangeParamNode(ctx, $1); }
    ;

/*-----------------.
| Enum declaration |
`-----------------*/

enum_declaration
    : "type" IDENTIFIER "enum" { ctx.varInfo->beginUDT(ctx, $2, "enum"); } enum_constant_list end_statement
        {
            $$ = newEnumDeclNode(ctx, $2, $5);
            ctx.varInfo->endUDT(ctx);
        }
    ;

enum_constant
    : IDENTIFIER
        {
            // Uninitialized enum constant (sequential integer values)
            $$ = newEnumConstNode(ctx, $1, nullptr, STEval::Long);
        }
    | IDENTIFIER "=" literal_const_expression
        {
            // Constant initialized from compile-time literal value
            $$ = newEnumConstNode(ctx, $1, $3, $3->evalType);
        }
    | IDENTIFIER "=" identifier_expression
        {
            // Constant with explicit initializer (a prev constant from this enum)
            $$ = newEnumConstNode(ctx, $1, $3, $3->evalType);
        }
    | IDENTIFIER "=" identifier_expression "." identifier_expression
        {
            // Constant initialized from a reference to a member constant of another enum
            const STEval stEval = enumMemberConstantReference(ctx, $3, $5);
            const SyntaxTreeNode * initExpr = newBinaryOpNode(ctx, STNode::ExprMemberRef, $3, $5);
            $$ = newEnumConstNode(ctx, $1, initExpr, stEval);
        }
    ;

enum_constant_list
    : enum_constant
    | enum_constant "," enum_constant_list
        {
            $$ = $1;
            $$->setChild(0, $3);
        }
    | %empty
        {
            $$ = nullptr;
        }
    ;

/*--------------------------------.
| Structured types and type alias |
`--------------------------------*/

type_alias_declaration
    : "type" IDENTIFIER "=" type_identifier { requireGlobalScope(ctx, "type alias"); } ";"
        {
            $$ = newTypeAliasNode(ctx, $2, $4);
        }
    ;

struct_declaration
    : "type" IDENTIFIER "struct" { ctx.varInfo->beginUDT(ctx, $2, "struct"); } struct_member_list end_statement
        {
            $$ = newStructDeclNode(ctx, $2, $5);
            ctx.varInfo->endUDT(ctx);
        }
    ;

struct_member_list
    : typed_var_declaration
    | typed_var_declaration "," struct_member_list
        {
            $$ = $1;
            $$->setChild(0, $3);
        }
    | %empty
        {
            $$ = nullptr;
        }
    ;

%%
